<!doctype html>
<html lang="pt-br">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Pulso do Farol - jogo de clique</title>
  <meta name="description" content="Jogo de clique simples: sincronize o pulso do farol e marque pontos em 30 segundos." />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Fraunces:wght@500;700&family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet" />
  <style>
    :root {
      color-scheme: light;
      --ink: #0b1f2c;
      --ink-soft: #2c4a5e;
      --sand: #f8f1e7;
      --sun: #ffb35c;
      --sun-strong: #ff8d5d;
      --sea: #1f4f63;
      --sea-deep: #0b2638;
      --mint: #17bebb;
      --panel: rgba(255, 255, 255, 0.75);
      --border: rgba(11, 31, 44, 0.15);
      --shadow: 0 24px 50px rgba(11, 31, 44, 0.2);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100%;
      font-family: "Space Grotesk", "Trebuchet MS", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(60% 40% at 20% 0%, rgba(255, 179, 92, 0.35), transparent 60%),
        radial-gradient(50% 50% at 80% 10%, rgba(23, 190, 187, 0.25), transparent 70%),
        linear-gradient(160deg, #f8f1e7 0%, #f6e7d3 45%, #dce5e8 75%, #b7d1dc 100%);
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background:
        radial-gradient(circle at 10% 20%, rgba(255, 255, 255, 0.4), transparent 45%),
        radial-gradient(circle at 85% 30%, rgba(255, 255, 255, 0.25), transparent 55%);
      pointer-events: none;
      opacity: 0.7;
    }

    .page {
      max-width: 1100px;
      margin: 0 auto;
      padding: 32px 20px 48px;
      display: grid;
      gap: 28px;
      position: relative;
      z-index: 1;
    }

    .hero {
      display: grid;
      gap: 20px;
      align-items: start;
    }

    .hero-text h1 {
      margin: 8px 0 6px;
      font-family: "Fraunces", "Georgia", serif;
      font-size: clamp(2.2rem, 4vw, 3.5rem);
      letter-spacing: 0.01em;
    }

    .eyebrow {
      text-transform: uppercase;
      letter-spacing: 0.24em;
      font-size: 0.72rem;
      color: var(--ink-soft);
      font-weight: 600;
    }

    .subtitle {
      margin: 0;
      font-size: 1.05rem;
      color: var(--ink-soft);
      max-width: 34ch;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
    }

    .stat {
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.7);
      border-radius: 18px;
      padding: 12px 14px;
      box-shadow: 0 10px 22px rgba(11, 31, 44, 0.12);
      backdrop-filter: blur(10px);
    }

    .stat .label {
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: var(--ink-soft);
      font-weight: 600;
    }

    .stat .value {
      display: block;
      font-size: 1.4rem;
      font-weight: 600;
      margin-top: 6px;
      color: var(--ink);
    }

    .play {
      display: grid;
      gap: 18px;
    }

    .scene {
      position: relative;
      padding: 18px;
      border-radius: 26px;
      background: linear-gradient(140deg, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.35));
      border: 1px solid rgba(255, 255, 255, 0.7);
      box-shadow: var(--shadow);
      display: grid;
      place-items: center;
      overflow: hidden;
      cursor: pointer;
      touch-action: manipulation;
    }

    .scene:focus-visible {
      outline: 2px solid var(--sun);
      outline-offset: 4px;
    }

    .scene::before {
      content: "";
      position: absolute;
      inset: -40%;
      background:
        radial-gradient(circle at 30% 30%, rgba(255, 179, 92, 0.25), transparent 50%),
        radial-gradient(circle at 70% 70%, rgba(23, 190, 187, 0.2), transparent 55%);
      opacity: 0.8;
      animation: drift 12s ease-in-out infinite;
      pointer-events: none;
    }

    canvas {
      width: min(90vw, 560px);
      aspect-ratio: 1 / 1;
      border-radius: 20px;
      background: #0b2638;
      border: 1px solid rgba(11, 31, 44, 0.35);
      box-shadow: inset 0 0 30px rgba(255, 255, 255, 0.08);
      display: block;
      position: relative;
      z-index: 1;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      text-align: center;
      padding: 24px;
      z-index: 2;
      color: #f5e9d9;
      opacity: 0;
      transition: opacity 0.4s ease;
      pointer-events: none;
    }

    .overlay.is-visible {
      opacity: 1;
    }

    .overlay-card {
      background: rgba(11, 31, 44, 0.75);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 16px;
      padding: 20px 24px;
      max-width: 320px;
      box-shadow: 0 18px 40px rgba(11, 31, 44, 0.45);
    }

    .overlay-card h2 {
      margin: 0 0 8px;
      font-family: "Fraunces", "Georgia", serif;
      font-size: 1.6rem;
    }

    .overlay-card p {
      margin: 0;
      font-size: 0.95rem;
      color: rgba(255, 255, 255, 0.8);
    }

    .feedback {
      position: absolute;
      top: 18px;
      right: 18px;
      z-index: 2;
      background: rgba(255, 255, 255, 0.85);
      color: var(--ink);
      padding: 8px 12px;
      border-radius: 999px;
      font-size: 0.8rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      opacity: 0;
      transform: translateY(-8px);
      transition: opacity 0.2s ease, transform 0.2s ease;
      pointer-events: none;
    }

    .feedback.show {
      opacity: 1;
      transform: translateY(0);
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }

    .difficulty {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      gap: 12px;
    }

    .difficulty-label {
      text-transform: uppercase;
      letter-spacing: 0.16em;
      font-size: 0.72rem;
      color: var(--ink-soft);
      font-weight: 600;
    }

    .difficulty-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .diff-btn {
      border: 1px solid rgba(11, 31, 44, 0.2);
      background: rgba(255, 255, 255, 0.75);
      color: var(--ink-soft);
      padding: 7px 14px;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.08s ease, background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
      box-shadow: 0 8px 14px rgba(11, 31, 44, 0.08);
    }

    .diff-btn:hover {
      transform: translateY(-1px);
      border-color: rgba(11, 31, 44, 0.35);
      background: rgba(255, 255, 255, 0.95);
      color: var(--ink);
    }

    .diff-btn.is-active {
      background: var(--sea);
      color: #f8f1e7;
      border-color: rgba(11, 31, 44, 0.6);
    }

    .diff-btn:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      transform: none;
    }

    .chip {
      background: rgba(255, 255, 255, 0.75);
      border: 1px solid rgba(11, 31, 44, 0.15);
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.85rem;
      color: var(--ink-soft);
      box-shadow: 0 8px 14px rgba(11, 31, 44, 0.08);
    }

    .tips {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .tip {
      background: var(--panel);
      border-radius: 18px;
      padding: 16px 18px;
      border: 1px solid rgba(255, 255, 255, 0.7);
      box-shadow: 0 12px 30px rgba(11, 31, 44, 0.12);
    }

    .tip h3 {
      margin: 0 0 6px;
      font-family: "Fraunces", "Georgia", serif;
      font-size: 1.1rem;
    }

    .tip p {
      margin: 0;
      color: var(--ink-soft);
      font-size: 0.95rem;
    }

    @keyframes drift {
      0%,
      100% {
        transform: translateY(0) rotate(0deg);
      }
      50% {
        transform: translateY(12px) rotate(3deg);
      }
    }

    @media (min-width: 900px) {
      .hero {
        grid-template-columns: 1.2fr 0.8fr;
        align-items: center;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .scene::before {
        animation: none;
      }

      .feedback {
        transition: none;
      }
    }
  </style>
</head>

<body>
  <main class="page">
    <header class="hero">
      <div class="hero-text">
        <span class="eyebrow">Jogo de clique</span>
        <h1>Pulso do Farol</h1>
        <p class="subtitle">Clique no ritmo do anel para manter a luz acesa.</p>
      </div>
      <div class="stats" aria-live="polite">
        <div class="stat">
          <span class="label">Pontos</span>
          <span class="value" id="score">0</span>
        </div>
        <div class="stat">
          <span class="label">Combo</span>
          <span class="value" id="combo">0</span>
        </div>
        <div class="stat">
          <span class="label">Tempo</span>
          <span class="value" id="time">30</span>
        </div>
        <div class="stat">
          <span class="label">Recorde</span>
          <span class="value" id="best">0</span>
        </div>
        <div class="stat">
          <span class="label">Precisao</span>
          <span class="value" id="accuracy">0%</span>
        </div>
      </div>
    </header>

    <section class="play">
      <div id="scene" class="scene" role="button" tabindex="0" aria-label="Clique para jogar">
        <canvas id="game" aria-label="Jogo Pulso do Farol"></canvas>
        <div id="feedback" class="feedback" aria-live="polite"></div>
        <div id="overlay" class="overlay is-visible" aria-hidden="false">
          <div class="overlay-card">
            <h2 id="overlay-title">Clique para comecar</h2>
            <p id="overlay-text">Acerte a faixa dourada e faca combos.</p>
          </div>
        </div>
      </div>
      <div class="difficulty" role="group" aria-label="Dificuldade">
        <span class="difficulty-label">Dificuldade</span>
        <div class="difficulty-buttons">
          <button type="button" class="diff-btn" data-diff="easy" aria-pressed="false">Facil</button>
          <button type="button" class="diff-btn" data-diff="medium" aria-pressed="false">Medio</button>
          <button type="button" class="diff-btn" data-diff="hard" aria-pressed="false">Dificil</button>
        </div>
      </div>
      <div class="legend">
        <span class="chip">Clique/Toque: marcar pulso</span>
        <span class="chip" id="duration-chip">Duracao: 30s</span>
        <span class="chip">Combo aumenta o bonus</span>
      </div>
    </section>

    <section class="tips">
      <div class="tip">
        <h3>Como pontuar</h3>
        <p>Quanto mais perto do centro da faixa dourada, maior a pontuacao.</p>
      </div>
      <div class="tip">
        <h3>Ritmo</h3>
        <p>O pulso acelera com o tempo. Ajuste o clique para manter a sequencia.</p>
      </div>
      <div class="tip">
        <h3>Objetivo</h3>
        <p>Mantenha a luz viva ate o tempo zerar e bata o recorde local.</p>
      </div>
    </section>
  </main>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scene = document.getElementById('scene');
    const feedback = document.getElementById('feedback');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlay-title');
    const overlayText = document.getElementById('overlay-text');
    const scoreEl = document.getElementById('score');
    const comboEl = document.getElementById('combo');
    const timeEl = document.getElementById('time');
    const bestEl = document.getElementById('best');
    const accuracyEl = document.getElementById('accuracy');
    const durationChip = document.getElementById('duration-chip');
    const diffButtons = Array.from(document.querySelectorAll('[data-diff]'));

    const state = {
      mode: 'idle',
      difficulty: 'easy',
      score: 0,
      combo: 0,
      hits: 0,
      total: 0,
      duration: 30,
      elapsed: 0,
      phase: 0,
      speed: 1.2,
      baseSpeed: 1.2,
      maxSpeed: 3.4,
      bandScale: 1,
      timeFactor: 0.05,
      comboFactor: 0.03,
      pulseRadius: 0,
      minR: 0,
      maxR: 0,
      targetR: 0,
      band: 0,
      centerX: 0,
      centerY: 0,
      stars: [],
      ripple: 0,
      messageTimer: 0,
      best: Number(localStorage.getItem('pulse_best') || 0)
    };

    const difficulties = {
      easy: {
        label: 'Facil',
        baseSpeed: 0.6,
        maxSpeed: 1.7,
        bandScale: 1.35,
        duration: 40,
        timeFactor: 0.02,
        comboFactor: 0.01
      },
      medium: {
        label: 'Medio',
        baseSpeed: 0.9,
        maxSpeed: 2.8,
        bandScale: 1,
        duration: 30,
        timeFactor: 0.04,
        comboFactor: 0.02
      },
      hard: {
        label: 'Dificil',
        baseSpeed: 1.55,
        maxSpeed: 4.3,
        bandScale: 0.78,
        duration: 25,
        timeFactor: 0.05,
        comboFactor: 0.03
      }
    };

    bestEl.textContent = state.best;

    function applyDifficulty(level) {
      const setting = difficulties[level] || difficulties.medium;
      state.difficulty = level;
      state.baseSpeed = setting.baseSpeed;
      state.maxSpeed = setting.maxSpeed;
      state.bandScale = setting.bandScale;
      state.duration = setting.duration;
      state.timeFactor = setting.timeFactor;
      state.comboFactor = setting.comboFactor;
      if (state.mode !== 'playing') {
        state.elapsed = 0;
        state.speed = state.baseSpeed;
      }
      diffButtons.forEach((button) => {
        const isActive = button.dataset.diff === level;
        button.classList.toggle('is-active', isActive);
        button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      });
      if (durationChip) {
        durationChip.textContent = `Duracao: ${setting.duration}s`;
      }
      if (state.mode === 'idle') {
        overlayText.textContent = `Acerte a faixa dourada e faca combos. Dificuldade: ${setting.label}.`;
      }
      updateHud();
      resize();
      localStorage.setItem('pulse_diff', level);
    }

    function setDifficultyButtonsEnabled(enabled) {
      diffButtons.forEach((button) => {
        button.disabled = !enabled;
      });
    }

    function setOverlay(title, text) {
      overlayTitle.textContent = title;
      overlayText.textContent = text;
      overlay.classList.add('is-visible');
      overlay.setAttribute('aria-hidden', 'false');
    }

    function hideOverlay() {
      overlay.classList.remove('is-visible');
      overlay.setAttribute('aria-hidden', 'true');
    }

    function calcAccuracy() {
      return state.total ? Math.round((state.hits / state.total) * 100) : 0;
    }

    function updateHud() {
      scoreEl.textContent = Math.floor(state.score);
      comboEl.textContent = state.combo;
      timeEl.textContent = Math.max(0, Math.ceil(state.duration - state.elapsed));
      accuracyEl.textContent = `${calcAccuracy()}%`;
      bestEl.textContent = state.best;
    }

    function showFeedback(message) {
      feedback.textContent = message;
      feedback.classList.add('show');
      state.messageTimer = 0.6;
    }

    function startGame() {
      state.mode = 'playing';
      state.score = 0;
      state.combo = 0;
      state.hits = 0;
      state.total = 0;
      state.elapsed = 0;
      state.phase = 0;
      state.speed = state.baseSpeed;
      state.ripple = 0;
      state.messageTimer = 0;
      setDifficultyButtonsEnabled(false);
      hideOverlay();
      updateHud();
    }

    function endGame() {
      state.mode = 'ended';
      const finalScore = Math.floor(state.score);
      if (finalScore > state.best) {
        state.best = finalScore;
        localStorage.setItem('pulse_best', String(finalScore));
      }
      updateHud();
      setOverlay(
        'Tempo esgotado',
        `Pontos ${finalScore} - Precisao ${calcAccuracy()}% - Clique para jogar de novo`
      );
      setDifficultyButtonsEnabled(true);
    }

    function registerHit() {
      if (state.mode !== 'playing') {
        return;
      }
      state.total += 1;
      const diff = Math.abs(state.pulseRadius - state.targetR);
      const bandRadius = state.band / 2;
      if (diff <= bandRadius) {
        state.hits += 1;
        const perfect = diff <= bandRadius * 0.4;
        state.combo += 1;
        const base = perfect ? 18 : 12;
        const bonus = Math.min(20, state.combo * (perfect ? 2 : 1));
        state.score += base + bonus;
        state.ripple = 1;
        showFeedback(perfect ? 'Perfeito!' : 'Boa!');
      } else {
        state.combo = 0;
        showFeedback('Fora!');
      }
      updateHud();
    }

    function handleInput() {
      if (state.mode === 'idle' || state.mode === 'ended') {
        startGame();
        return;
      }
      registerHit();
    }

    function generateStars(size) {
      const count = Math.floor(size / 7);
      state.stars = Array.from({ length: count }, () => ({
        x: Math.random() * size,
        y: Math.random() * size * 0.75,
        r: Math.random() * 1.4 + 0.4,
        a: Math.random() * 0.5 + 0.15
      }));
    }

    function resize() {
      const cssSize = canvas.clientWidth;
      if (!cssSize) {
        return;
      }
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = cssSize * dpr;
      canvas.height = cssSize * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      state.centerX = cssSize / 2;
      state.centerY = cssSize / 2;
      const base = cssSize / 2;
      state.minR = base * 0.35;
      state.maxR = base * 0.85;
      state.targetR = base * 0.6;
      state.band = base * 0.18 * state.bandScale;
      generateStars(cssSize);
    }

    function drawBackground(width, height) {
      const bg = ctx.createRadialGradient(
        state.centerX,
        state.centerY,
        state.minR * 0.3,
        state.centerX,
        state.centerY,
        state.maxR * 1.8
      );
      bg.addColorStop(0, '#214d63');
      bg.addColorStop(1, '#0b2538');
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, width, height);

      state.stars.forEach((star, index) => {
        const twinkle = 0.5 + 0.5 * Math.sin(state.phase * 0.7 + index);
        ctx.fillStyle = `rgba(255, 233, 200, ${star.a * twinkle})`;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
        ctx.fill();
      });

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
      for (let i = 0; i < 4; i++) {
        const baseY = height * (0.68 + i * 0.08);
        ctx.beginPath();
        for (let x = 0; x <= width; x += 20) {
          const offset = Math.sin(x * 0.02 + state.phase + i) * 3;
          if (x === 0) {
            ctx.moveTo(x, baseY + offset);
          } else {
            ctx.lineTo(x, baseY + offset);
          }
        }
        ctx.stroke();
      }
    }

    function drawTargetRing() {
      ctx.save();
      ctx.beginPath();
      ctx.arc(state.centerX, state.centerY, state.targetR, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255, 203, 128, 0.28)';
      ctx.lineWidth = state.band;
      ctx.shadowColor = 'rgba(255, 203, 128, 0.2)';
      ctx.shadowBlur = 18;
      ctx.stroke();
      ctx.restore();
    }

    function drawPulse() {
      ctx.save();
      ctx.beginPath();
      ctx.arc(state.centerX, state.centerY, state.pulseRadius, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255, 236, 196, 0.95)';
      ctx.lineWidth = 4;
      ctx.shadowColor = 'rgba(255, 206, 138, 0.6)';
      ctx.shadowBlur = 14;
      ctx.stroke();
      ctx.restore();
    }

    function drawRipple() {
      if (state.ripple <= 0) {
        return;
      }
      const alpha = state.ripple;
      ctx.save();
      ctx.beginPath();
      ctx.arc(
        state.centerX,
        state.centerY,
        state.targetR + (1 - alpha) * state.band,
        0,
        Math.PI * 2
      );
      ctx.strokeStyle = `rgba(255, 216, 158, ${0.6 * alpha})`;
      ctx.lineWidth = 2 + alpha * 4;
      ctx.stroke();
      ctx.restore();
    }

    function drawLighthouse() {
      const towerW = state.minR * 0.5;
      const towerH = state.minR * 0.85;
      const x = state.centerX;
      const y = state.centerY + state.minR * 0.15;
      ctx.save();
      ctx.fillStyle = '#f6eadc';
      ctx.beginPath();
      ctx.moveTo(x - towerW * 0.5, y + towerH * 0.45);
      ctx.lineTo(x + towerW * 0.5, y + towerH * 0.45);
      ctx.lineTo(x + towerW * 0.3, y - towerH * 0.45);
      ctx.lineTo(x - towerW * 0.3, y - towerH * 0.45);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = '#d9c8b5';
      ctx.fillRect(x - towerW * 0.3, y - towerH * 0.6, towerW * 0.6, towerH * 0.15);

      ctx.beginPath();
      ctx.arc(x, y - towerH * 0.65, towerW * 0.18, 0, Math.PI * 2);
      ctx.fillStyle = '#ffb35c';
      ctx.shadowColor = 'rgba(255, 179, 92, 0.6)';
      ctx.shadowBlur = 12;
      ctx.fill();
      ctx.restore();
    }

    function draw() {
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      ctx.clearRect(0, 0, width, height);
      drawBackground(width, height);
      drawTargetRing();
      drawPulse();
      drawRipple();
      drawLighthouse();
    }

    function tick(now) {
      if (!tick.last) {
        tick.last = now;
      }
      const dt = Math.min(0.033, (now - tick.last) / 1000);
      tick.last = now;

      if (state.mode === 'playing') {
        state.elapsed += dt;
        const difficulty = state.elapsed * state.timeFactor + state.combo * state.comboFactor;
        state.speed = Math.min(state.maxSpeed, state.baseSpeed + difficulty);
        if (state.elapsed >= state.duration) {
          state.elapsed = state.duration;
          endGame();
        }
      } else {
        state.speed = 0.65;
      }

      state.phase += dt * state.speed * Math.PI * 2;
      const wave = (Math.sin(state.phase) + 1) / 2;
      state.pulseRadius = state.minR + wave * (state.maxR - state.minR);

      if (state.ripple > 0) {
        state.ripple = Math.max(0, state.ripple - dt * 2);
      }

      if (state.messageTimer > 0) {
        state.messageTimer = Math.max(0, state.messageTimer - dt);
        if (state.messageTimer === 0) {
          feedback.classList.remove('show');
        }
      }

      if (state.mode === 'playing') {
        updateHud();
      }

      draw();
      requestAnimationFrame(tick);
    }

    scene.addEventListener('pointerdown', (event) => {
      event.preventDefault();
      scene.focus();
      handleInput();
    });

    scene.addEventListener('keydown', (event) => {
      if (event.code === 'Space' || event.code === 'Enter') {
        event.preventDefault();
        handleInput();
      }
    });

    diffButtons.forEach((button) => {
      button.addEventListener('click', () => {
        if (state.mode === 'playing') {
          showFeedback('Termine a rodada para mudar');
          return;
        }
        applyDifficulty(button.dataset.diff);
      });
    });

    window.addEventListener('resize', resize, { passive: true });
    applyDifficulty(localStorage.getItem('pulse_diff') || 'easy');
    setDifficultyButtonsEnabled(true);
    resize();
    updateHud();
    requestAnimationFrame(tick);
  </script>
</body>

</html>
